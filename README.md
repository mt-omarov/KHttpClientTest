# `KHttpClient`
Проект нацелен на портирование библиотеки `Symfony/HttpClient`([тут ссылка](https://symfony.com/doc/current/http_client.html)). 
### Исходный код портированной библиотеки расположен [тут](https://github.com/mt-omarov/KHttpClient).

## Главные проблемы и задачи
`KPHP` – это транслятор `PHP` кода в `C++`. То есть, с целью поддержки данной библиотеки код должен быть компилируемым, не сугубо интерпретируемым.\
Это подразумевает следующее:
1. Использование строгой типизации.
2. Запрет на смешивание сложных данных и недопущение смешивания различных типов данных в принципе.
3. Имплементация неподдерживаемого функционала.
4. Обход конфликтов для использования библиотеки как на `PHP`, так и на `KPHP` (требуется для тестирования).

Для начала будет портирован модуль `CurlHttpClient`. \
`KPHP` изначально поддерживает (почти все необходимые) функции cURL библиотеки: cURL в `KPHP` это тот же cURL, но в обёртке. Однако, есть функционал, который пока что не поддерживается (установка обработчиков событий на хендлеры запросов, `curl_pause()` и другое). Это мешает полноценному переносу библиотеки, однако её тестовая версия может быть сделана.

## `CurlHttpClient`
Не затрагивая детали, обозначим главные компоненты данного модуля:
* CurlResponse - единица запросов,
* CurlClientState - состояние клиента,
* CurlHttpClient - класс модуля.

### Конструктор
```PHP
$client = new CurlHttpClient(null);
```
Вызов конструктора подразумевает следующую последовательность действий:
1. **Вызов конструтора класса параметров запроса `Options`**: \
*Позволяет хранить множество параметров различных типов, избегая проблему строгой типизации.*
2. **Вызов функции подготовки запроса `prepareRequest` класса `ExtractedHttpClient`**: \
*Вадилирует все опции и параметры запроса, делает возможным дальнейшую отправку запроса к серверу.*
3. **Создание объекта класса состояний клиента `CurlClietState:`**
*Данный класс является связующим между хендлерами и мультихендлерами запросов.*

### Создание запроса `request`
```PHP
$url = 'https://<someExampleUrl>';
$response = $client->request('GET', $url);
```
1. **Валидация передаваемых опций через метод `prepareRequest()`.**.
2. **Подготовка других параметров запроса с помощью функции `ExtractedHttpClient`.**.
3. **Создание объекта запроса класса `CurlResponse`**: \
*Данный класс хранит всю информацию о запросе. 
В частности, хранит связь между запросом и его мультихандлером. \
Создание объекта запроса означает добавление запроса в очередь мультихандлера, 
установка всех опций с помощью `curl_setopt()` и, помимо прочего, создание временного потока для отладки*.
### Получение статуса запроса `getStatusCode`
```PHP
$response = $client->request('GET', $url);
var_dump($statusCode = $response->getStatusCode());
```
Этот метод позволяет получить код состояния запроса. \
Его вызов имеет довольно сложную конструкцию и требует использования функции-генератора. 
KPHP пока не поддерживает генераторы, поэтому используется рекурсия. Для этого используется класс `StreamIterator`.
Оказалось, что структура выглядит следующим образом:
1. Создание объекта **StreamIterator.**.
2. **Использование функциональности StreamIterator**: используются методы для получения информации о запросе в сочетании с curl_multi_exec().

## Документация расположена по [ссылке](https://git.miem.hse.ru/kaa/kaa/-/blob/CurlHttpClient/src/HttpClient/KHttpClient%20documentation.md)
